diff --git a/src/dist/component/package.rs b/src/dist/component/package.rs
index dfccc661..6ff172a2 100644
--- a/src/dist/component/package.rs
+++ b/src/dist/component/package.rs
@@ -113,6 +113,7 @@ impl Package for DirectoryPackage {
                     } else {
                         builder.move_file(path.clone(), &src_path)?
                     }
+                    nix_patchelf_if_needed(&target.prefix().path().join(path.clone()), &src_path)
                 }
                 "dir" => {
                     if self.copy {
@@ -135,6 +136,132 @@ impl Package for DirectoryPackage {
     }
 }
 
+fn nix_patchelf_if_needed(dest_path: &Path, src_path: &Path) {
+    use std::fs::File;
+    use std::os::unix::fs::FileExt;
+
+    struct ELFReader<'a> {
+        file: &'a mut File,
+        is_32bit: bool,
+        is_little_end: bool,
+    }
+
+    impl<'a> ELFReader<'a> {
+        const MAGIC_NUMBER: &'static [u8] = &[0x7F, 0x45, 0x4c, 0x46];
+        const ET_EXEC: u16 = 0x2;
+        const ET_DYN: u16 = 0x3;
+        const PT_INTERP: u32 = 0x3;
+
+        fn new(file: &'a mut File) -> Option<Self> {
+            let mut magic_number = [0; 4];
+            file.read_exact(&mut magic_number).ok()?;
+            if Self::MAGIC_NUMBER != magic_number {
+                return None;
+            }
+            let mut ei_class = [0; 1];
+            file.read_exact_at(&mut ei_class, 0x4).ok()?;
+            let is_32bit = ei_class[0] == 1;
+            let mut ei_data = [0; 1];
+            file.read_exact_at(&mut ei_data, 0x5).ok()?;
+            let is_little_end = ei_data[0] == 1;
+            Some(Self {
+                file,
+                is_32bit,
+                is_little_end,
+            })
+        }
+
+        fn is_exec_or_dyn(&self) -> bool {
+            let e_type = self.read_u16_at(0x10);
+            e_type == Self::ET_EXEC || e_type == Self::ET_DYN
+        }
+
+        fn e_phoff(&self) -> u64 {
+            if self.is_32bit {
+                self.read_u32_at(0x1C) as u64
+            } else {
+                self.read_u64_at(0x20)
+            }
+        }
+
+        fn e_phentsize(&self) -> u64 {
+            let offset = if self.is_32bit { 0x2A } else { 0x36 };
+            self.read_u16_at(offset) as u64
+        }
+
+        fn e_phnum(&self) -> u64 {
+            let offset = if self.is_32bit { 0x2C } else { 0x38 };
+            self.read_u16_at(offset) as u64
+        }
+
+        fn has_interp(&self) -> bool {
+            let e_phoff = self.e_phoff();
+            let e_phentsize = self.e_phentsize();
+            let e_phnum = self.e_phnum();
+            for i in 0..e_phnum {
+                let p_type = self.read_u32_at(e_phoff + i * e_phentsize);
+                if p_type == Self::PT_INTERP {
+                    return true;
+                }
+            }
+            false
+        }
+
+        fn read_u16_at(&self, offset: u64) -> u16 {
+            let mut data = [0; 2];
+            self.file.read_exact_at(&mut data, offset).unwrap();
+            if self.is_little_end {
+                u16::from_le_bytes(data)
+            } else {
+                u16::from_be_bytes(data)
+            }
+        }
+
+        fn read_u32_at(&self, offset: u64) -> u32 {
+            let mut data = [0; 4];
+            self.file.read_exact_at(&mut data, offset).unwrap();
+            if self.is_little_end {
+                u32::from_le_bytes(data)
+            } else {
+                u32::from_be_bytes(data)
+            }
+        }
+
+        fn read_u64_at(&self, offset: u64) -> u64 {
+            let mut data = [0; 8];
+            self.file.read_exact_at(&mut data, offset).unwrap();
+            if self.is_little_end {
+                u64::from_le_bytes(data)
+            } else {
+                u64::from_be_bytes(data)
+            }
+        }
+    }
+
+    let Some(mut dest_file) = File::open(dest_path).ok() else {
+        return;
+    };
+    let Some(elf) = ELFReader::new(&mut dest_file) else {
+        return;
+    };
+    if !elf.is_exec_or_dyn() {
+        return;
+    }
+    let mut patch_command = std::process::Command::new("@patchelf@/bin/patchelf");
+    if elf.has_interp() {
+        patch_command
+            .arg("--set-interpreter")
+            .arg("@dynamicLinker@")
+    } else {
+        patch_command.arg("--set-rpath").arg("@libPath@")
+    };
+
+    debug!("patching {dest_path:?} using patchelf");
+    if let Err(e) = patch_command.arg(dest_path).output() {
+        warn!("failed to execute patchelf: {e:?}");
+    }
+}
+
 #[derive(Debug)]
 pub(crate) struct TarPackage<'a>(DirectoryPackage, temp::Dir<'a>);
